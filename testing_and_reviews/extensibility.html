<h1>Pocket Pickup</h1>
<h2>User Documentation</h2>

<h3>Team Poseidon</h3>
<p>
	Sergey Naumets (snaumets@cs)<br/>
	Victor Farkas (vfarkas@cs)<br/>
	Jacob Gile (jjgile@cs)<br/>
	Patrick Larson (palarson@cs)<br/>
	Kane Swanson (kane@cs, kdswan@uw)<br/>
	Isaiah Mathieu (imathieu@cs)<br/>
</p>

<h3>Extensibility - Required Changes to Replace Parse</h3>

<p>
When designing the Pocket Pickup application, we chose to follow a three-tier architecture which separates back end persistent storage, middle tier translation, and front end UI and presentation.  Because we carefully maintained this separation, the work involved in replacing Parse would consist mostly of building that replacement - the actual replacement is very easy.  Removing our backend would require architecting a new persistent storage scheme, and designing a system to manage our Pocket Pickup users.
</p>
<p>
Supposing that we switched away from Parse due to unforeseen circumstances, such as legal obstacles or sudden price increases, we would likely architect our backend in a manner as similar to Parse as we could.  Parse uses MongoDB for its backend storage.  Thus, switching to our own MongoDB deployment would be the most accessible solution.  We would implement a web server to expose MongoDB to our application, with some framework that could provide a RESTful API, such as Node.js.  We could then host this service on Amazon EC2 for easy access and scalability.
</p>
<p>
If instead, we needed to switch away from Parse due to performance or scalability shortcomings, a different design would be required.  We could experiment with a relational database, and host a PostgreSQL database with some custom web server on Amazon EC2.  This would be a larger setback, and likely would not be necessary, as Parse and NoSQL databases have been seen to be scalable and performant.
</p>
<p>
The actual implementation changes in how data is persisted would require changes to the translation layer than issues queries to our backend.  We maintained a clean separation of front-end data objects that store information in native Android objects, and back-end data objects that hold ParseObjects.  Then, our front end objects would not need to change.  Instead, only the way we build queries and issue them to the backend would change.  The interface could remain the same, as our modularization encapsulated backend behavior.  Additionally, we store the columns names in a utility class in the application.  These database columns could be used to build a schemaless MongoDB backend that functions exactly as the Parse Backend does, or they could be used as the foundation for architecting a relational database.  What the queries actually look like would depend on the backend replacement that we choose.
</p>
<p>
Because we rely on Parse for managing users of our application, if Parse is no longer available, we would need to redesign how this is handled.  Even with Parse we decided that login could only be done through Facebook accounts, and this could still be the case without Parse.  Rather than connecting to Facebook through Parse's convenient interface, we would interact with the Facebook Android SDK directly.  Facebook provides tutorials on how to manage this that are simple and readable. Because we use Facebook merely as identification, the only real change would be to use the Facebook Login token from each user as their personal identification, rather than the unique identification generated by ParseUser.
</p>
<p>
Another major design change involves our usage of Parse's ability to run queries in the background.  The quick solution would be to abandon this functionality and have all backend queries block.  This is not ideal, since some work can still be done while these queries run.  In the long term, we would want to issue this queries with the Callback design pattern, where we can notify our application when these queries finish, and take care of the results accordingly.
</p>
<p>
Finally, there are a few cases where modularity is broken, and so a few front end classes need to be updated.  In our create game activity, the game to be created requires a Parse User ID, to identify the game's creator.  This would be replaced by the Facebook Login token that we use to identify users.  MainActivity also requires ParseUser objects for logging out and ParseObject objects for getting a game's ID to display information in the GameActivity.  The reliance on ParseUser would instead use the Facebook Login token for logging out with the Facebook SDK, and the ParseObject reliance would be replaced by grabbing the game's unique key from our backend, rather than using the ParseObject unique id.  Lastly, when the application loads, we connect to the backend to build the list of available sports.  We could remove this reliance on Parse in two ways.  The first would be to do the same dynamic loading, but query our new backend directly, instead of by building up a BiMap of ParseObjects.  The other solution would be to have a static list of sports.  This would make more sense for a relational database where the schema does not change often, but could function just as well on a non-relational solution.

<p>
Although it is unlikely that we would need to abandon Parse as our backend, we have designed defensively so that we are flexible to change if the need presents itself.
</p>
